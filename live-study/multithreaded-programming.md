# 멜티쓰레드 프로그래밍

## 목표

자바의 멀티쓰레드 프로그래밍에 대해 학습하세요.

## 학습할 것 (필수)

- Thread 클래스와 Runnable 인터페이스
- 쓰레드의 상태
- 쓰레드의 우선순위
- Main 쓰레드
- 동기화
- 데드락

---

#### 프로세스와 쓰레드

**프로세스**

메모리를 할당받아 **실행중인 프로그램**을 의미한다.

프로세스는 프로그램을 수행하는데 필요한 데이터와 메모리 등의 자원, 쓰레드로 구성되어있다.

**쓰레드**

프로세스보다 조금 더 작은 단위로, **프로세스 내에서 실행되는 흐름의 단위**를 의미한다.

프로세스의 자원을 이용해서 실제로 작업을 수행한다.

모든 프로세스에는 한개 이상의 쓰레드를 가지고 있으며, 둘 이상의 쓰레드를 가진 프로세스를 멀티쓰레드 프로세스라고 한다.

> 쓰레드를 사용하는 이유?
> 동시에 들어오는 많은 요청에 대해 대기 시간을 줄이기 위해서다. 즉, **동시에 여러개의 요청을 처리하여 처리속도를 빠르게 하는 것**이 목적이다.

### Thread 클래스와 Runnable 인터페이스

Thread 클래스 혹은 Runnable 인터페이스를 사용하면 자바에서 쓰레드를 생성할 수 있다.

Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없기 때문에, Runnable 인터페이스를 구현하는 방법이 일반적이다.

**Thread 클래스 상속**

```java
class CustomizeThread1 extends Thread {
	@Override
    public void run() {
        // 수행할 코드
        System.out.println("Thread 클래스를 상속한 run 함수 실행");
    }
}
```

**Runnable 인터페이스 구현**

```java
class CustomizeThread2 implements Runnable {
    // Runnable 인터페이스에는 추상 메소드 run()만 정의되어있다.
    @Override
    public void run() {
        // 수행할 코드
        System.out.println("Runnable 인터페이스을 구현한 run 함수 실행");
    }
}
```

Thread 클래스 혹은 Runnable 인터페이스의 run 함수를 구현하여 만든 쓰레드는 아래와 같은 방법으로 호출하여 사용할 수 있다.

이 때, start() 메소드가 끝날 때까지 기다리지 않고, 바로 그 다음줄을 실행하게 된다.

```java
class MyClass {
	public static void main(String[] args) {
        // Thread 클래스를 상속했을 때, 쓰레드를 생성하는 방법
		Thread t1 = new CustomizeThread1();
        
        // Runnable 인터페이스를 구현했을 때, 쓰레드를 생성하는 방법
		Runnable r = new CustomizeThread2();
        Thread t2 = new Thread(r);
		
        // 생성한 쓰레드 실행
        // 바로 실행되는 것이 아니라 실행대기 상태에 있다가 자기 차례에 실행됨
        // 한번 실행 종료된 쓰레드를 다시 실행할 수 없다.
        System.out.println("t1 쓰레드 실행");
		t1.start(); // t1 쓰레드가 끝날 때까지 기다리지 않으므로 바로 다음줄이 실행된다.
        System.out.println("t2 쓰레드 실행");
		t2.start();
        /* 결과
        	t1 쓰레드 실행
			t2 쓰레드 실행
			Thread 클래스를 상속한 run 함수
			Runnable 인터페이스을 구현한 run 함수
        */
        
        t1.start(); // 실행 종료된 쓰레드를 실행하는 것이기 때문에 IllegalThreadStateException 예외가 발생한다.
	}
}
```

> Runnable 인터페이스를 구현한 클래스는 직접적인 쓰레드라고 할 수 없기 때문에 구현 클래스를 Thread 클래스의 생성자 인수로 넘겨주어야한다.
> ⇒ 쓰레드를 호출하기 위해서는 Thread 클래스의 `currentThread()`를 호출하여 쓰레드에 대한 참조를 얻어와야하기 때문에 Thread 객체를 만들어 쓰레드에 대한 참조를 가져와 쓰레드를 호출하게된다.
>
> `currentThread()` : 현재 실행중인 쓰레드의 참조를 반환한다.

> 쓰레드의 이름
> 아래와 같은 방법으로 생성자나 메소드를 통해 지정할 수 있으며, 지정하지 않을 경우 'Thread-번호' 형식으로 이름이 정해진다.
>
> ```
> Thread(Runnable target, String name);
> Thread(String name);
> void setName(String name);
> ```
>
> `getName()`으로 쓰레드의 이름을 가져올 수 있다.

<br/>

### 쓰레드의 상태

쓰레드의 상태에는 아래와 같은 상태가 존재한다.

| 상태         | 상태 설명      | 상세 설명                                             |
| ------------ | -------------- | ----------------------------------------------------- |
| New          | 객체 생성 단계 | 쓰레드 생성 후, start() 메소드가 호출되지 않은 상태   |
| Runnable     | 실행 대기      | 실행 중이거나 언제든지 실행 상태로 갈 수 있는 상태    |
| Blocked      | 일시정지       | 사용하고자 하는 객체의 락이 풀릴 때까지 기다리는 상태 |
| Waiting      | 일시정지       | 다른 쓰레드가 통지할 때까지 기다리는 상태             |
| Time_waiting | 일시정지       | 주어진 시간 동안 기다리는 상태                        |
| Terminated   | 종료           | 실행을 마친 상태                                      |

Java 5부터 `getState()` 메소드를 통해 쓰레드의 상태를 확인할 수 있다.

![image](https://user-images.githubusercontent.com/49746644/106892270-311c6380-672f-11eb-86a6-e405066ecd5c.png)

각 쓰레드의 상태를 변경할 때는 사용되는 메소드들은 다음과 같다.

| 메소드             | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| sleep(long millis) | 일정시간동안 쓰레드를 멈추게 한다.                           |
| interrupt()        | 현재 쓰레드의 작업을 취소한다. 쓰레드를 종료시키는 것이 아니다.<br />(`InterruptedException` 예외를 발생시키며 중단) |
| join()             | 자신의 작업 중간에 다른 쓰레드의 작업을 참여시켜 종료될때까지 기다린다.<br />쓰레드 자신이 하던 작업을 잠시 멈추고 다른 쓰레드가 지정된 시간동안 작업을 수행하도록 할 때 사용 |
| yield()            | 자신에게 주어진 실행시간을 다음 쓰레드에게 양보한다.         |
| suspend()          | 현재 쓰레드를 멈추게 한다. (사용을 권장하지 않는다.)         |
| resume()           | suspend()에 의해 정지된 쓰레드를 실행 대기 상태로 변경한다. (사용을 권장하지 않는다.) |
| stop()             | 호출되는 즉시 쓰레드가 종료된다.(사용을 권장하지 않는다.)    |

> sleep 메소드는 항상 현재 실행 중인 쓰레드에 대해 작동한다.

> suspend(), resume(), stop()은 교착상태(deadlock)을 일으키기 쉽게 작성되어있어 사용을 권장하지 않는다.

> 쓰레드는 무조건 실행된 순서대로 실행되는 것이 아니다.

<br/>

### 쓰레드의 우선순위

Java에서 각 쓰레드는 우선순위에 관한 멤버 변수를 가지고 있다. 쓰레드는 이 우선순위 값에 따라 쓰레드가 얻는 실행시간이 달라진다.

쓰레드의 우선순위는 1에서 10 사이의 값을 가지며 숫자가 높을수록 우선순위가 높다.

Java에서 쓰레드의 우선순위를 확인하거나 세팅하는 방법은 아래와 같다.

```java
void setPriority(int numPriority); // 쓰레드의 우선순위 변경
int getPriority(); // 쓰레드의 우선순위 조회

public static final int MAX_PRIORITY = 10; // 최대 우선순위
public static final int NORM_PRIORITY = 5; // 우선순위를 정하지 않으면 기본으로 가지는 우선순위
public static final int MIN_PRIORITY = 1; // 최소 우선순위
```

```java
class CustomThread extends Thread {
	@Override
	public void run() {
		System.out.println("실행 쓰레드 명 : " + Thread.currentThread().getName()); // 현재 실행중인 쓰레드 이름 출력
	}
}

Thread t1 = new CustomThread();
Thread t2 = new CustomThread();
Thread t3 = new CustomThread();

t1.setPriority(1);
t3.setPriority(10);

System.out.println("t1 쓰레드 우선순위" + t1.getPriority());
System.out.println("t2 쓰레드 우선순위" + t2.getPriority());
System.out.println("t3 쓰레드 우선순위" + t3.getPriority());

t1.start();
t2.start();
t3.start();

/* 결과
	t1 쓰레드 우선순위1
	t2 쓰레드 우선순위5
	t3 쓰레드 우선순위10
	쓰레드 명 : Thread-2
	쓰레드 명 : Thread-1
	쓰레드 명 : Thread-0
*/
// 우선순위가 절대적으로 지켜지는 것이 아니라 실행할 때마다 결과가 다르게 나올 수 있다.
// 우선순위가 높을수록 상대적으로 많은 양의 실행시간이 주어진다.
```

<br/>

### Main 쓰레드

Java 어플리케이션도 하나의 프로세스이다.

자바 어플리케이션이 실행될 때 JVM에 의해 Main 쓰레드가 생성되고 main() 메소드를 실행하게된다.

메인 쓰레드만 실행되면 **싱글 쓰레드 어플리케이션**, 메인 쓰레드에서 다른 쓰레드를 생성하여 실행하는 경우 **멀티 쓰레드 어플리케이션**이라고 한다.

즉, 메인 쓰레드는 자바 어플리케이션을 실행하기 위한 쓰레드를 의미한다고 볼 수 있다.

> 멀티쓰레드인 경우, 메인쓰레드가 종료되어도 다른쓰레드가 작업을 마치지 않았다면 프로세스는 종료되지 않는다.

> **데몬 쓰레드**란? 메인 쓰레드의 작업을 돕는 보조적인 역할을 하는 쓰레드를 의미한다.
> 메인 쓰레드가 종료되면 데몬 쓰레드는 강제적으로 자동 종료된다. 데몬이 될 쓰레드의 `setDaemon(true)`를 호출해주어 만들 수 있다.
>
> 데몬 쓰레드를 사용하는 이유?
> 부가적인 작업을 수행하는 쓰레드를 선언할 때 데몬 쓰레드를 사용하게 된다.
> ex) 모니터링을 하는 쓰레드를 사용하다가 메인 쓰레드가 종료되면 모니터링을 위한 쓰레드도 종료되어야한다. (종료되지 않으면 프로세스가 종료되지 않음)

<br/>

### 동기화

**동기화**란? 한 쓰레드가 사용 중인 리소스를 다른 쓰레드가 접근하지 못하도록 막는 것을 의미한다.

동기화를 통해 공유 자원(임계 영역)에 대한 접근을 제어하여 멀티 스레드 프로그래밍에서 동시에 공유자원에 접근이 이루어져도 프로그램 실행에 문제가 없을 때, `쓰레드에 안전(Thread-safe)`하다고 한다.

자바에서 동기화 하기 위해서는 Synchronized 키워드를 사용할 수 있다.

**Synchronized 키워드**

동기화를 사용하기 위한 가장 대표적인 방법이다.

1. 메소드 전체를 임계 영역으로 지정

   ```java
   public synchronized void 메소드명() {
   	...
   }
   ```

2. 특정한 영역을 임계 영역으로 지정

   ```java
   // 메소드 내부 일부 코드를 감싼다.
   synchronized(객체의 참조변수) {
   	...
   }
   ```

두 방법 모두 lock의 획득과 반납이 모두 자동적으로 이루어지므로 임계 영역만 잘 설정해주면 된다.

> 임계 영역 : 프로그램에서 임계 자원을 이용하는 부분으로 공유 자원의 독점을 보장하는 코드 영역을 의미한다.

<br/>

### 데드락

**데드락(교착 상태)**란? 두 개 이상의 쓰레드가  서로 상대방의 작업이 끝나기를 기다리고 있어 아무것도 완료되지 못하는 상태를 말한다.

시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.

**데드락의 발생 조건**

아래 조건 중 하나라도 만족하지 않으면 교착 상태는 발생하지 않는다.

1. 상호 배제(Mutual exclusion) : 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
2. 점유 대기(Hold and wait) : 최소한 하나의 자원을 점유하고 있으며 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
3. 비선점(No preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
4. 순환 대기(Circular wait) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.

**교착 상태 관리 방법**

1. 예방 : 교착 상태 발생 조건 중 하나를 제거함으로써 해결하는 방법
   1. 상호 배제 부정 : 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.
   2. 점유 대기 부정 : 프로세스가 실행되기 전 필요한 모든 자원을 할당한다.
   3. 비선점 부정 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다.
   4. 순환 대기 부정 : 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.
2. 회피 : 교착 상태가 발생하면 피해나가는 방법
   1. 은행원 알고리즘(Banker’s Algorithm) : 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하여 교착 상태를 회피하는 기법

> Ref : https://jwprogramming.tistory.com/12

#### 참고 자료

https://yadon079.github.io/2021/java%20study%20halle/week-10

https://blog.naver.com/swoh1227/222214667950

https://sujl95.tistory.com/63