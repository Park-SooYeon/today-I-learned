![image](https://user-images.githubusercontent.com/49746644/108376745-a5362b80-7246-11eb-9e93-a3ee5a5d0858.png)

관계형 데이터베이스를 많이 사용하지만 사용법만 알고 관계형 모델에 대한 것은 잘 모르는 것 같다는 생각이 들어 **관계형 데이터베이스 실전 입문** 책을 읽게 되었다.

책 내용을 정리하여 올리는 것은 저작권에 위반이 되는 것 같아 각 장을 읽고 느낀점을 적어보고자 한다.

## 1장. SQL과 관계형 모델

해당 장에서는 관계형 모델에 대한 설명과 SQL과 관계형 모델의 차이점 등에 대한 것이 적혀있었다.

해당 장을 읽으며 나는 관계형 모델이 무엇인지 모르고 단지 SQL만 공부하고 사용했었다는 생각이 들었다. 관계형 모델이 집합론을 바탕으로 한 데이터 모델이라는 것도 처음 알았다. 또한, 릴레이션과 테이블, 튜플과 행, 속성과 컬럼 같은 용어들이 뜻은 모두 동일한데 다르게 불리는 이유를 알지 못했는데 이 책을 읽고 해당 용어 또한 SQL과 관계형 모델이 가지는 차이에 의해 다르게 불린다는 점을 알 수 있었다.

관계형 모델은 뭔가 이론적인 논리에 치중된 느낌이 강했고, SQL은 RDB를 사용하는데에 치중된 느낌이 강했던 것같다.

사실 아직 관계형 모델에 대해 크게 와닿지 않으며 약간은 개념이 모호한 느낌이 있다. 일단 책을 계속 읽어보며 관계형 모델에 대해 더욱 공부해봐야겠다. 책을 다 읽어도 모호하다면 책을 여러번 읽다보면 어느정도는 모호함이 사라지지 않을까 생각한다.

## 2장. 술어논리와 관계형 모델

해당 장에서는 술어논리에 대한 설명을 바탕으로 술어논리와 집합론, 관계형 모델의 관계를 설명해준다.

술어논리에 대해 설명하기 위해 논리학과 관련된 용어들이 많이 나오는데 처음보는 용어들이 많아 읽는데 어려움이 있었다. 그러나 해당 장을 읽고 DB에 질의를 할 때, 술어논리를 기반으로 술어(쿼리)에 대한 **논리연산**을 수행하여 술어에 참이 되는 집합을 새롭게 받게 된다는 것을 알 수 있었다. 결국 쿼리를 작성하는 행위는 술어를 정의하는 것이라는 것을 알게 되었다.

또한, 해당 장에서는 자세한 이유가 서술되어 있지 않았으나 술어논리가 정규화가 무엇이고 왜 필요한지에 대해 이해하는데 필요하다고 서술되어 있었다. 왜 정규화에 술어논리가 필요한 이유는 짐작 가지 않지만 궁금해졌다. 책을 더 읽으면서 해당 궁금증을 풀고 더 공부해야겠다.

## 3장. 정규화 논리(첫 번째) - 함수 종속성 ~ 4장. 정규화 논리(두 번째) - 결합 종속성

해당 장에서는 정규화에 대한 설명과 정규화 과정 중, 정규화의 출발인 1NF와 함수 종속성을 제거하는 2NF~BCNF, 결합 종속성을 제거하는 4NF~6NF에 대해 설명하는 내용이 서술되어있었다.

각 정규화 과정을 관계형 모델에 맞는 집합 관점에서 설명해주는데 이는 각 정규화 과정에 대해 더 이해하기 쉬웠던 것 같다. 특히 그동안 정규화에 대해 공부하면서도 함수 종속성을 제거하는 과정인 2NF~BCNF 과정에서의 차이를 크게 체감하지 못했었는데 이 책을 읽고서 각 과정의 차이에 대해 이해할 수 있었다. 4NF와 5NF의 차이에 대해서도 명제와 예시를 이용한 설명이 있어 좀 더 이해하기 쉬웠었다.

해당 장을 공부하면서 결국 함수 종속성과 결합 종속성에 의한 정규화를 해야하는 기준은 키가 아닌 속성의 유무뿐만이 아니라 각 속성이 갖는 튜플의 관계에 따라서도 구분할 수 있겠다는 생각이 들었다. 함수 종속성은 이름과 나이같이 각 속성이 n:1의 관계를 지닐 수 있을 때에 존재하고, 결합 종속성은 이름과 수업같이 각 속성이 m:n의 관계를 지닐 수 있을 때 존재하는 것으로 볼 수 있겠다는 생각이 들었다. 즉, 명제가 가진 의미가 무엇이냐에 따라 구분할 수도 있겠다는 생각이 들었다. 이런점 때문에 저자는 술어논리가 정규화를 이해하는데 필요하다고 한것 같다.

또한, 기존에 정규화를 공부했었음에도 불구하고 각 정규화 단계의 차이를 이해하지 못하고 단지 용어로만 각 단계를 구분지어 공부한 것 같다는 생각이 들어 반성하는 시간도 가지게 되었다.

## 5장. 릴레이션의 직교성

해당 장에서는 릴레이션의 직교성에 대한 내용과 정규화와 직교화를 통해 중복을 해결해 얻는 이점에 대한 내용이 서술되어 있었다.

릴레이션의 직교성에 대한 이야기는 처음들어보았다. 데이터의 중복을 없애기 위해서는 정규화를 고려하는 것만으로도 충분하다고 생각했는데 릴레이션 사이의 중복 튜플에 관해서도 고려해야한다는 것을 처음 알았다.

물론 직교성을 확인하는데 있어서 정규화가 필요하기 때문에 정규화를 기본으로 중복을 없앤다는 것은 동일하다. 그러나 정규화에서 그치지 않고, 정규화 후 각 릴레이션의 속성들과 튜플들이 가지는 의미들에 대해 고려하는 것이 필요하다는 생각이 들었다. 지금까지는 DB 설계를 할때, 최대한 테이블의 분할만을 생각했는데 각 테이블이 가지는 의미에 대해서도 검토를 해야겠다고 생각했다.

또한, RDB에서 데이터의 중복을 피해야하는 이유가 단순히 저장공간의 낭비를 줄이기 위해서만 아니라 쿼리 혹은 테이블의 의미를 명확하게 할 수 있고 그에 따른 이점들이 많기 때문에 중복을 피해야한다는 것을 알 수 있었다.

## 6장. 도메인 설계 전략

해당 장에서는 도메인 설계 전략과 ID 설계, SQL로 도메인을 표현하는 방법에 대한 내용이 서술되어 있었다.

해당 장을 읽고서 나는 지금까지 잘못된 방식, 순서로 DB를 설계하고 있었다는 것을 깨달을 수 있었다.

해당 장에서 저자는 "적절한 DB 설계는 응용프로그램에 관한 이해 없이는 할 수 없다"고 이야기한다. 처음에는 이 말을 보고 의아함을 느꼈었다. 왜냐하면 나는 지금까지 프로젝트를 진행할 때, 항상 DB 설계를 진행하고 나온 ERD를 기반으로 프로그램을 설계하는 방식으로 진행해왔기 때문이다. 당시에는 테이블 간의 관계를 형성하는 것이 더 중요하다고 생각되어 이게 맞는 설계 순서라고 생각했었다.

그러나 저자의 생각을 듣고 지금 다시 생각해보면 DB 설계 후 프로그램을 설계 할 때마다 놓치는 데이터들이 있어 결국 프로그램 설계를 하면서도 DB를 계속 변경하고 있었음을 깨달을 수 있었다. 이는 만들 프로그램에 대한 이해도가 부족했기 때문에 초기 DB 설계가 잘못되어 발생한 문제라고 생각한다. 만약 프로그램 설계를 먼저 했더라면 DB 설계가 더 수월해지고 놓치는 데이터들도 최소로 할 수 있지 않았을까라는 생각이 들었다. 예를 들어 REST API를 만든다고 가정했을 때, 먼저 REST API에 대한 설계를 진행하고 DB 설계를 들어가는 방식으로 진행하는 것이 더 좋지 않았을까라는 생각이 들었다.

또한, ID 사용에 관해서도 생각해 보는 계기가 되었다.

지금까지는 ID를 사용할 때 단순히 그냥 모든 테이블에 자동으로 증가하는 int형 칼럼을 추가해 각 데이터를 구분할 수 있게 하면 되는 것이 아닌가라고 생각했었다. 그렇기 때문에 m:n 관계에서 생성되는 관계 테이블에도 쓸데없는 ID 칼럼을 추가했었다. (실제로 [BoosTrallo 프로젝트](https://github.com/boostcamp-2020/Project04-B-Whale/wiki/ER-Diagram)를 진행할 때 사용한 관계 테이블에 컬럼이 3개였고 추가한 ID 컬럼은 사용한 기억이 없는 것 같다...)

그러나 해당 장을 읽고서 이는 매우 불필요한 작업이며 오히려 DB의 성능을 떨어뜨리는 작업이였음을 알 수 있었다. ID를 지정할 때에도 신중하게 많은 고민이 필요하겠다는 생각을 하게 되었다.

DB 설계든 ID의 설계든 설계자에 생각에 따라 모두 다르게 나올 수 있기 때문에 무엇이 정답이라고는 말할 수 없다고 생각한다. 그러나 많은 사람들이 좀 더 선호하는 설계방식은 존재하며 그것은 그 설계방식이 갖는 이점이 많고 효율적이기 때문에 존재하는 방식이라고 생각한다. 해당 장을 읽고 그동안 내가 설계를 해온 방식에 대해 많이 돌아보는 시간을 가질 수 있었다.

## 7장. NULL과의 싸움

해당 장에서는 NULL이 존재할 때의 문제점과 NULL을 처리하는 대책에 대해 서술되어 있었다.

해당 장을 읽고서 DB에서의 NULL 처리가 얼마나 중요한지 알게 되었다. 칼럼에 NULL이 포함되어 있으면 NULL이 쿼리의 처리결과와 옵티마이저의 성능에 안좋은 영향을 미친다는 것을 알 수 있었다.

그러나 실제 RDB를 사용했을 때, 회원의 나이와 같이 필수로 입력할 필요가 없는 데이터를 저장할 때 NULL을 사용하게 되는 경우가 많았다. 그렇다면 필수로 입력할 필요가 없는 데이터에 대한 저장은 어떻게 처리해야되는걸까? NULL을 제거하기 위해서 입력한 값이 없을 때, NULL 대신 임의로 -1과 같은 개발자가 지정한 기본값을 사용하는 것을 생각했었는데 저자는 이 방식 또한 NULL을 사용하는 것과 동일하거나 오히려 상황이 나빠지는 대책이라고 한다.

또한, 저자도 NULL은 제거해야하지만 DB에서는 NULL을 완전히 제거하는 것은 불가능하다고 말한다. 그렇다면 결국 관계형 모델에 맞는 DB 설계를 항상 할 수 없는 것이 아닌가라는 생각이 들었다.

관계형 모델에서 NULL을 사용하는 것은 위험하다는 것은 이해했는데 어떻게 NULL을 잘 제거해서 사용할 수 있는지는 아직 잘 모르겠다. 책을 더 읽어보면 알 수 있지 않을까 하는 생각을 가지고 책을 더 읽어봐야겠다.

## 8장. SELECT를 공략하자

해당 장에서는 SELECT의 기본 구조와 SELECT의 다양한 모습에 대해 서술되어 있었다.

해당 장을 읽고서 집계함수와 서브쿼리를 사용했을 때에도 NULL에 대한 처리를 해주어야 한다는 것을 알 수 있었다. 지금까지 SUM, COUNT와 같은 집계함수를 사용해본적은 있으나 테이블이 비어있는 경우에 대해서는 고려한적이 없었던 것 같다. 이는 쿼리문이 원하는대로 작동하지 않을 수 있는 경우가 생기는 위험한 행동이였다는 것을 깨달을 수 있었다.

또한, SELECT를 사용한 SQL문을 작성할 때 쿼리가 가지는 의미 즉, 무엇을 위한 쿼리인지 알 수 있도록 쿼리를 작성하는 것이 중요하겠다는 생각이 들었다. 무엇을 해야하는지 정의하고 쿼리를 작성하면 좀 더 관계형 조작과 가까운 SELECT를 수행하여 성능을 높일 수 있고, 해당 쿼리가 원하는 결과를 도출해내는지 확인하기에도 쉽지 않을까라고 생각했기 때문이다.

이전에는 단순히 일부 상황에서만 원하는 결과가 나오는 쿼리를 짜기에 급급했었는데 이제부터라도 쿼리가 가지는 의미를 생각하며 원하는 결과를 도출하는 쿼리를 짜도록 노력해야겠다는 생각이 들었다.

